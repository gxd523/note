[TOC]

## lamda
* 匿名函数，所以省去`fun`关键字
* 基本格式：`{`参数`->`函数体`}`
* 最后一行为返回值，所以不用写`return`
* 注意参数不用括号包裹，函数体不用花括号包裹
* 没有参数就没有`->`，一个参数默认为`it`，可以省略`it ->`
* `sum(1, 2)`等价于`sum.invoke(1, 2)`，函数作为变量调用时的`()`其实是运算符，`invoke()`是对应的具名函数
* `inline fun funcA(lamdaArg : ()->Unit)`函数(funA)带有`inline`修饰符时，`lamda`表达式里的`return `表示从`lamda`所在的函数(funA)返回，注意：`lamda`只是表达式，不算真正的函数
* 函数类型的参数，可以传入`lamda`表达式，也可以传入符合参数和返回值定义的任意函数（此时叫作函数引用，例`::print`），此时用`::函数名`表示，如果是成员函数用`类名::函数名`表示
* 注意：将函数引用传入时(`::`方式)，如果函数引用是扩展函数，`类名::函数名`要多加一个类名的实例对象参数，`对象::函数名`则不用

## 高阶函数
* 函数作为参数或返回值的函数叫做`高阶函数`
* 最后一个参数为函数类型，可将`lamda`写到括号外，`abc(123){...}`，如果只有一个参数，可省略括号，`abc{...}`

### 常见高阶函数
* `let()`：可改变返回值
* `apply()`：仍返回原值
* `with()`：和`apply()`很想
* `forEach()`
* `map()`
* `flatmap()`
* `reduce()`
* `fold()`
* `filter()`
* `take()`：取前n个元素
* `takeWhile()`：取到不满足条件为止的n个元素
* `takeIf()`：满足条件就取
* `use()`：封装了关闭流
* `block()`

## 扩展
* 扩展函数：带有接收者的函数，`<接收者类型>.<method>()`
    * 扩展函数内会带有接收者(Receiver)的引用，可看做隐藏参数
* 扩展方法可替代Java中的静态工具类
* 扩展属性由于没有`backing field`，所以要显示定义访问器

## 运算符重载
* 重载方法必须是扩展或成员函数
* 只能重载已有的运算符，例`+`、`-`、`*`、`/`
* 重载函数的名称必须为运算符对应的`具名函数`
* 对参数个数有要求，参数类型及返回值不做要求
* 基础类型的运算符禁止重载
* 一般写成类中的成员函数，控制重载范围

操作符 | 函数名
:---: | :---:
a+b | plus
a-b | minus
a*b | times
a/b | div
a%b | rem
a+=b | plusAssign
a-=b | minusAssign
a*=b | timesAssign
a/=b | divAssign
a%=b | remAssign
+a | unaryPlu
-a | unaryMin
!a | not
++a , a++ | inc
–a , a– | dec
== | equals()
!= | !equals()
\> , < , >= , <= | compareTo()
... | rangeTo()

## 闭包
* 在一个函数A中返回了另一个函数B,只有函数B才可以访问函数A中的内容,这个现象的概念叫做闭包
* 内部方法持有外部方法的状态(变量之类的)

## 内联
* `inline`用来修饰高阶函数，将函数体(参数)内联到函数调用处，避免创建函数参数对象及闭包
* 内联属性不能有`backing field`
* 

## 伴生
* 类内部定义的单例对象，可直接类名点调用对象的成员
* 用来替代静态工具类

## 代理
* 代理具体指代理`getter`、`setter`
* `by`是运算符重载，对应具名函数`getValue(thisRef: Any?, property: KProperty<*>)`、`setValue(thisRef: Any?, property: KProperty<*>, value: T)`
* `property`指`by`左边的委托对象，`thisRef`为`property`作为属性所在的类的实例

## backing field
* 扩展属性、接口属性、内联属性都没有

## 中缀表达式
* `infix`修饰的，只有一个参数的，成员或扩展函数
* 避免滥用，会降低可读性
* 一般用在`DSL`

## object
* `object 类名`：单例类
* `object : 接口名`：匿名内部类
* `companion object`：伴生对象，类中的单例实例对象

## 数据类
* 自动生成`toString()`、`hashCode()`
* `val (id, name) = Country(1, "美国")`
* `(属性, 属性...)`是运算符，具名函数为`componentN()`
* 数据类型不可继承，可用`allopen`插件解决
* 数据类型没有无参构造函数，可用`noarg`插件解决

## 内部类
* `kotlin`内部类默认是静态的，非静态需要加`inner`
* 内部类调用外部类的成员用`this@外部类名`
* 匿名内部类用`object : 类或接口名`生成
* `kotlin`里的`object`匿名内部类更强大，可以匿名继承实现多个类或接口

## DSL
* 编写`Gradle`的`Grovvy`是动态语言，编译时不做检查，所以IDE提示也很差


## 其他
* Java的静态方法及属性可用`包函数`、`扩展函数`、`伴生对象`替换
* 可见性修饰符`internal`范围为同一`module`下
* 延迟属性
* `try/catch`表达式
* 函数可变数量参数`vararg`
* `高阶函数`：作为形参或返回值或变量的函数，必须为匿名函数
* `具名或匿名`
* `crossinline`
* `reified`：和`inline`配合使用
* SAM
* `const val`等价于Java的`final`，是编译期常量，`val`是运行时常量，编译器在编译期无法确定它的值，本质是个变量，仍然可以通过反射修改值

### 密封类
* 密封类`sealed class`，子类需定义在相同文件中，个数可数，类似枚举实例可数

### 区间
* 用`..`隔开的，两端为基础类型，数字、字符，String不行
* `(1..2)`就是一个`IntRange`实例

### 尾递归
* `递归`能实现的`迭代`也能实现
* `递归`返回判断处理不当或层数太深，可能造成`stackoverflow`，`迭代`不会
* `迭代`效率高，但可读性差
* 递归函数加`tailrec`修饰符，会将递归转为迭代
* 尾递归：递归函数在调用自己之后没有其他代码