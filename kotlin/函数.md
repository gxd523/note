[TOC]

## 函数
* Kotlin中函数和类一样是一等公民，有类型、可以赋值
* 函数的类型：由参数和返回值表示，如`(Int)->String`
* `函数引用`：和对象引用一样，函数也有引用，也有类型
* `lamda`及匿名函数的引用：函数变量，有名函数引用：`::函数名`，成员函数引用：`类名::函数名`或`对象::函数名`，注意后者函数引用类型已从`Person.()->Unit`变为`()->Unit`
* 注意`Person.()->Unit`、`(Person)->Unit`、`Function1<Person,Unit>`是等价的
* 函数既然有类型，就能被类继承：`class A :()->Unit`

## lamda
* 本质是匿名函数，赋值给变量后，变量就是它的函数名
* 有类型，如`()->Unit`
* 基本格式：`{`参数`->`函数体`}`
* 最后一行为返回值，所以不用写`return`
* 最后一行可以加`Unit`，表示无返回值
* 注意参数不用括号包裹，函数体不用花括号包裹
* 没有参数就没有`->`，一个参数默认为`it`，可以省略`it ->`
* `lamda`调用时的`()`实际是运算符，对应具名函数：`invoke()`，`sum(1, 2)`等价于`sum.invoke(1, 2)`
* `inline fun funcA(lamdaArg : ()->Unit)`函数(funA)带有`inline`修饰符时，`lamda`表达式里的`return `表示从`lamda`所在的函数(funA)返回，注意：`lamda`只是表达式，不算真正的函数，其他情况下`lamda`内貌似不能`return`，要加标签`return@Label`
* 注意：将函数引用传入时(`::`方式)，如果函数引用是扩展函数，`类名::函数名`要多加一个类名的实例对象参数，`对象::函数名`则不用

## 高阶函数
* 函数作为参数或返回值的函数叫做`高阶函数`
* ``val func: Person.() -> Unit = Person::func`
* 抛弃Java中方法的概念，把函数放到和类一样的高度，高阶函数的出现就会变成很自然的一种事情了，就像对象作为参数和返回值一样
* 高阶函数和成员方法是一样的
* 最后一个参数为函数类型，可将`lamda`写到括号外，`abc(123){...}`，如果只有一个参数，可省略括号，`abc{...}`

### 常见高阶函数
函数 | 含义
:---: | :---
`let()` | T.let(block: (T) -> R): R
`use()` | T.use(block: (T) -> R): R	(T : Closeable?)
`run()` | T.run(block: T.() -> R): R 
`also()` | T.also(block: (T) -> Unit): T
`apply()` | T.apply(block: T.() -> Unit): T
`with()` | with(receiver: T, block: T.() -> R): R，和`run()`很想 
`forEach()` | 
`map()` | 元素映射成新的元素，再把元素组合成集合
`flatmap()` | 元素映射成集合，再把集合拼接成新的集合
`reduce()` | 将元素依次按规则聚合，元素类型不变
`fold()` | 给定初始值，将元素依次按规则聚合，元素类型变为初始值类型
`filter()` | 集合过滤元素 
`first()` | 第一个满足条件的
`take()` | 取前n个元素
`takeWhile()` | 取到不满足条件为止的n个元素
`takeIf()` | 满足条件就取
`block()` | 
`groupBy()` | 

## 扩展函数
* 带有`receiver`的函数叫做`方法`，Java中没有函数
* 扩展函数：带有`receiver`的函数，`<接收者类型>.<method>()`
* 如果`receiver`当作函数的第一参数的话，那么这个方法就是一个函数
* 扩展函数可替代Java中的静态工具类
* 扩展函数需要扩展类的对象调用
* 包级扩展函数，也可以在扩展类内部调用，基本和成员函数没差了
* 扩展属性由于没有`backing field`，所以要显示定义访问器

## 运算符重载
* 重载方法必须是扩展或成员函数
* 只能重载已有的运算符，例`+`、`-`、`*`、`/`
* 重载函数的名称必须为运算符对应的`具名函数`
* `a + b`等价于`a.plus(b)`
* 对参数个数有要求，参数类型及返回值不做要求
* 基础类型的运算符禁止重载
* 一般写成类中的成员函数，控制重载范围

### 常见运算符
操作符 | 函数名
:---: | :---:
a+b | plus
a-b | minus
a*b | times
a/b | div
a%b | rem
a+=b | plusAssign
a-=b | minusAssign
a*=b | timesAssign
a/=b | divAssign
a%=b | remAssign
+a | unaryPlu
-a | unaryMin
!a | not
++a , a++ | inc
–a , a– | dec
== | equals()
!= | !equals()
\> , < , >= , <= | compareTo()
... | rangeTo()

## 闭包
* 在一个函数A中返回了另一个函数B,只有函数B才可以访问函数A中的内容,这个现象的概念叫做闭包
* 内部方法持有外部方法的状态(变量之类的)

## 内联函数
* 内联函数：`inline`修饰的高阶函数
* 内联函数实际是将函数体(函数类型的参数)内联到函数调用处，避免创建函数参数对象及闭包，减少了性能开销
* 内联函数，函数类型的参数前加上`crossinline`，表示`lamda`禁止`non-local return`
* 内联函数，函数类型的参数前加上`noinline`，表示不内联
* 内联属性不能有`backing field`，因为内联的是`getter`、`setter`函数

## 中缀表达式
* `infix`修饰的，只有一个参数的，成员或扩展函数
* 避免滥用，会降低可读性
* 一般用在`DSL`

## 尾递归
* `递归`能实现的`迭代`也能实现
* `递归`返回判断处理不当或层数太深，可能造成`stackoverflow`，`迭代`不会
* `迭代`效率高，但可读性差
* 递归函数加`tailrec`修饰符，会将递归转为迭代
* 尾递归：递归函数在调用自己之后没有其他代码

## 柯里化Curry&偏函数
* 多元函数变换成一元函数调用链
* `fun curryFoo(a: Int) = fun(b: Boolean) = fun(c: Float): String`
* 调用：`curryFoo(1)(true)(2.3f)`
* `fun <P1, P2, P3, R> Function3<P1, P2, P3, R>.convertCurry() = fun(p1: P1) = fun(p2: P2) = fun(p3: P3) = this(p1, p2, p3)`
* 偏函数：多元函数传入部分参数后得到的新函数
* `fun <P1, P2, R> Function2<P1, P2, R>.convertPartial(p2: P2) = fun(p1: P1) = this(p1, p2)`

## SAM(Single Abstract Method)
* Java没有函数类型，所以单函数接口即使用`lamda`表示：`Runnable runnable = () -> { };`表示，`lamda`的类型仍然是`Runnable`，所以`lamda`本质是匿名内部类
* 在Kotlin中，如果将函数类型的变量(如`lamda`)，赋值给单函数Java接口类型的参数，就会发生SAM转换，将函数类型替换成匿名内部类对象`object : Runnable{...}`
* 注意：Kotlin中`lamda`是函数类型，单函数接口是类类型，完全不等价
* 注意：`Runnable{}`是`Runnable`接口类型匿名对象，等价于`object : OnClickListener {...}`，而`{view:View->}`是`(View)->Unit`函数类型
* 所以将`{}`赋值给`Runnable`类型的参数时，会SAM转换成`object : Runnable {...}`，将`lamda`替换成生成的`Runnable`类型匿名对象

## 其他特性
* 变长参数：`vararg`
* 伪多返回值：`Pair`、`Triple`
* 具名参数
* 默认参数：可减少函数重载