[TOC]

## 协程Coroutine
* 协程是可以自行控制`挂起`、`恢复`，从而控制程序运行流程的程序
* 协程可以用来解决异步任务，控制流转移
* 协程可以让异步代码同步化，降低异步程序设计复杂度，异步逻辑同步写法
* Kotlin的协程不是协同调度CPU资源的那个协程，而是kotlin语言的特性
* `org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.9`：协程基础库
* `org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.9`：协程Android库，提供Android UI调度器

### 协程分类
* 有栈协程：每个协程分配单独调用栈，类似线程调用栈(StackOverFlow)
* 无栈协程：不分配单独调用栈，挂起点状态通过闭包或对象(`Continuation`)保存
* 对称协程：调度权可以转移给任意协程，协程之间是对等关系
* 非对称协程：调度权只能转移给调度自己的协程，协程存在父子关系

### 协程基本要素
* 挂起点：挂起函数调用处
* 挂起函数只能在其他挂起函数或协程中调用
* 挂起函数调用时包含了协程`挂起`的语义，返回值`Any?`为`COROUTINE_SUSPENDED`
* 挂起函数返回时包含了协程`恢复`的语义，`continuation.resume(value)`

#### Continuation
* `Continuation`：保存挂起点状态，用于恢复运行流程
* 协程本身也是`Continuation `
* `suspendCoroutine((Continuation<T>) -> Unit):T`
* `suspendCoroutine`获取挂起函数的`Continuation`，也就是`completion`

#### suspend函数
* `suspend fun foo():Int`类型为`suspend ()->Int`
* 可以看成`fun foo(continuation:Continuation<Int>):Any?{}`
* suspendLamda等价于suspend函数：`suspend {}`
* 没有挂起时，Any是没有挂起时的返回结果，挂起时，Any返回的是挂起标志对象`COROUTINE_SUSPANDED`
* 只有异步调用`Continuation.resume()`，才能真正挂起 

### 协程创建
* 创建协程：`fun <T> (suspend () -> T).createCoroutine(
  completion: Continuation<T>):Continuation<Unit>`
* 创建协程：`fun <R, T> (suspend R.() -> T).createCoroutine(
receiver: R,completion: Continuation<T>): Continuation<Unit>`
* 返回的`Continuation<Unit>`是协程本体，本体里的`resume()`执行完之后，就会调用`completion`
* `suspend函数`本身执行需要一个Continuation实例在恢复时调用，即`completion`，返回值`Continuation<Unit>`则是创建出来的协程的载体，用于启动协程
* `suspendCoroutine()`内的`SafeContinuation`用来确保resume()只被调用一次，其次是确保 在当前线程调用栈上直接调用不会挂起

```
println("开始请求...")
val suspendFunc = suspend {
    suspendCoroutine<String> {
        thread {
            Thread.sleep(3000)
            try {
                it.resume("guoxiaodong")
            } catch (e: Exception) {
                it.resumeWithException(e)
            }
        }
    }
}
suspendFunc.createCoroutine(object : Continuation<String> {
    override val context: CoroutineContext = EmptyCoroutineContext

    override fun resumeWith(result: Result<String>) {
        println("result-->${result.getOrNull()}")
    }
}).resume(Unit)// 启动协程，使用startCoroutine就不用调用resume
println("程序结束...")
```

#### 协程挂起恢复要点
* 协程体内的代码都是通过`Continuation.resumeWith()`调用
* 每调用一次`label`加1，每一个挂起点对应一个case分支
* 挂起函数在返回`COROUTINE_SUSPENDED`时才会挂起
* 调用了`suspend函数`就会`挂起`，直到调用`continuation.resume()`才会`恢复`

### 协程上下文
* 协程执行过程中需要携带的数据
* 索引：CoroutineContext.Key，元素：CoroutineContext.Element

#### 拦截器
* `ContinuationInterceptor`：是一类协程上下文元素，可以对协程上下文所在协程的Continuation进行拦截

## 其他
* 启动模式：
	* `DEFAULT`：立即开始调度协程体
	* `LAZY`：只有在需要(start/join/await)时才开始调度
	* `ATOMIC`：立即开始调度，且在第一个挂起点前不能被取消
	* `UNDISPATCHED`：立即在当前线程执行协程体，直到遇到第一个挂起点(后面取决于调度器)

### Job
* 可以对应Java的`Thread`来理解

### 调度器
* 继承`CoroutineContext`

### 作用域
### Context
* CoroutineContext


### 拦截器
### 挂起函数

## 协程应用
* 异步逻辑同步化表达，用返回值的同步写法，替代回调的异步写法，避免回调地狱
* 通过`suspend`、`resume`控制程序运行流程
* 用更少的线程做更多的任务
	* 协程是运行在线程上的代码块
	* 线程阻塞时，使用挂起操作，使线程回到线程池，去做其他任务
	* 避免线程阻塞，引起上下文切换带来的资源消耗

### 作用域Scope
* 协程代码都必须包含在一个范围内，就好比说：只有在这个圈里可以使用协程。这个scope用于跟踪管理其内部的协程。

### Builder
* 其协程代码与非协程代码的桥梁。其负责在非协程代码里启动协程，即在协程scope里build一个协程代码块，例如：`launch`与`async`

### 调度器Dispatcher
* 它负责具体执行线程。使用协程builder构建了协程后，总的有人去执行啊，这个任务就是由dispatcher完成的，它会调度线程来运行协程代码。
* Dispatchers.Default、Dispatchers.IO，Dispatchers.Main

