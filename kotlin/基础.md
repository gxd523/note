## 空安全
* `String?`
* `s?.length`
* `elvis表达式`：`s ?: ...`，`?:`左边为空就执行右边
* 用`a?.let{} ?: b`代替`if(a != null) a.let{} else b`
* `as?`
* `a!!`：断言非空，也会将类型强转为非空类型，不建议使用
* `String!`：平台类型，客观存在，不能主观定义，此时Kotlin编译器无法判断是否为可空类型

## 表达式
* 表达式有返回值 
* `when表达式`括号里的条件可以写到分支里
```
when {
	x is String ->...
	x == "a" ->...
	else ->...
}
```
* `when表达式`条件括号也能赋值，范围在表达式内
```
when(val length = read()){
	0 ->...
	is String ->...
}
```

Kotlin 表达式 | 对应Java
:---: | :---:
if...else | 三元
when | switch...case
try...catch | try...catch

## 智能类型转换
* 智能类型转换作用在代码块内 
* 判断类型代码块内，不用强转即可调用B的成员
```kotlin
val a:A = B()
if(a is B){
	a.bFunc()
}
```
* val变量判空代码块内，类型自动转为非空类型
```
val s: String? = null
if (s != null) {
    println(s.length)// 不用写成s?.length
}
```
* 安全类型强转：`as?`

## 区间
* 支持8中基础类型
* 闭区间：`1..2`，`IntRange`实例，还有`CharRange`、`LongRange` ...
* 开区间：`1 until 10`，等价于[1, 10)
* 倒序区间：`10 downTo 1`，等价于[10, 1]，和`..`相反
* 区间步长：`1..10 step 2`，取值1、3、5、6、9
* `FloatRange`是连续的，`IntRange`是离散的
* 打印区间：`joinToString()`
* 区间迭代和数组一样
* 包含关系：`3 in intRange`
* `for(i in 0 until array.length)`等价于`for(i in array.indices)`

## 集合变化&序列
* flatMap { 0 until it }
* asSequence()将流变成懒汉式
* 集合添加元素可以使用`+=`，移除`-=`，set、get元素`list[index]`
* Map是这样`map[key]`，所以集合和数组是一回事
* `Pair`：键值对，`1 to "a"`、`Pair(1, "a")`、`(x, y)`(解构表达式)，实际是个`data class`
* `Triple`：
* 判断包含关系：`元素 in 集合`

## Java&Kotlin混合开发
* `@JvmField`：
* `@JvmStatic`：

## 其他
* 用局部变量引用外部变量，防止外部变量发生变化，导致直接使用发生异常
* `const val`等价于Java的`final`，是编译期常量，`val`是运行时常量，编译器在编译期无法确定它的值，本质是个变量，仍然可以通过反射修改值
* `typealias`：类型别名，例：`typealias OnClick = (View)->Unit`