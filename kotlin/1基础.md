[TOC]

## 基础
* `val`：只读变量
	* 在函数中等价于常量
	* 作为属性、顶级变量则可定义getter，导致值改变
* `const val`：编译时常量
	* 只能是基础类型、String，因为立即用字面量初始化
	* 以内联形式编译：编译时用常量的值去替换常量调用处的变量名
	* 定义在顶级、object
	* 等价Java的静态常量
* `==`：比较值是否相等
* `===`：比较内存地址

## 空安全
* 可空类型：`String?`，与`String`是两种类型
* `s?.length`：为空返回null
* `elvis表达式`：`s ?: ...`，`?:`左边为空就执行右边
* 用`a?.let{} ?: b`代替`if(a != null) a.let{} else b`
* `as?`
* `a!!`：断言非空，也会将类型强转为非空类型，不建议使用
* `String!`：平台类型，客观存在，不能主观定义，此时Kotlin编译器无法判断是否为可空类型

## 表达式
* 表达式有返回值 
* `when表达式`括号里的条件可以写到分支里
```
when {
	x is String ->...
	x == "a" ->...
	else ->...
}
```
* `when表达式`条件括号也能赋值，范围在表达式内(switch...case)
```kotlin
when(val length = read()){
	0 ->...
	is String ->...
}
```

Kotlin 表达式 | 对应Java
:---: | :---:
if...else | 三元
when | switch...case
try...catch | try...catch

### 解构表达式
* 多返回值：`val (id, name) = Country(1, "美国")`
* 只要在类中添加运算符重载即可`operator fun componentN(): T {}`
* `data class`的属性都重载了`componentN`，实现了解构，例如：Pair

## 智能类型转换
* 智能类型转换作用在代码块内 
* 判断类型代码块内，不用强转即可调用B的成员
```kotlin
val a:A = B()
if(a is B){
	a.funcB()
}
```
* val变量判空代码块内，类型自动转为非空类型
```
val s: String? = null
if (s != null) {
    println(s.length)// 不用写成s?.length
}
```
* 安全类型强转：`as?`

## 区间
* 支持8中基础类型
* 闭区间：`1..2`，`IntRange`实例，还有`CharRange`、`LongRange` ...
* 开区间：`1 until 10`，等价于[1, 10)
* 倒序区间：`10 downTo 1`，等价于[10, 1]，和`..`相反
* 区间步长：`1..10 step 2`，取值1、3、5、6、9
* `FloatRange`是连续的，`IntRange`是离散的
* 打印区间：`joinToString()`
* 区间迭代和数组一样
* 包含关系：`3 in intRange`
* `for(i in 0 until array.length)`等价于`for(i in array.indices)`

## 数组
* 创建数组：
	* `intArrayOf(1, 2, 3)`
	* `IntArray(5){ it + 1 }`
* `IntArray`对应Java的`int[]`
* `Array<Int>`对应Java的`Integer[]`
* 打印：`contentToString()`
* 是否包含：`3 in array`

## 集合
* 不可变接口：List\<T>、Map\<T>、Set\<T>
* 创建方式：listOf()、mapOf()、mapOf()
* 可变接口：MutableList\<T>、MutableMap\<T>、MutableSet\<T>
* 创建方式：mutableListOf()、mutableMapOf()、mutableSetOf()
* `list.add(2)`等价于`list += 2`，因为重载了运算符
* `list.get(5)`等价于`list[5]`，又是运算符重载
* `list.set(0, 5)`等价于`list[0] = 5`

## 集合变化&序列
* flatMap { 0 until it }
* asSequence()将流变成懒汉式
* 集合添加元素可以使用`+=`，移除`-=`，set、get元素`list[index]`
* Map是这样`map[key]`，所以集合和数组是一回事
* `Pair`：键值对，`1 to "a"`、`Pair(1, "a")`、`(x, y)`(解构表达式)，实际是个`data class`
* `Triple`：
* 判断包含关系：`元素 in 集合`

## Java&Kotlin混合开发
* `@JvmField`：去除getter、setter，变成静态属性
* `@JvmStatic`：变成静态方法，用在object、companion object中
* `@JvmName`：
	* 作用在文件上：指定包级函数在java中的类名：@file:JvmName("TextUtil")
	* 作用在方法上：改变java调用时的方法名
	* 作用在属性上：改变java调用时的属性名

## Kotlin实现Java的static
* 顶层申明
* `object`、`companion object`(不是官方建议)
* 建议每个工具类创建一个kt文件用`顶层申明`的方式写工具方法
* 像TAG这种，属于类的变量，可以用`companion object`

## 其他
* 用局部变量引用外部变量，防止外部变量发生变化，导致直接使用发生异常
* `const val`等价于Java的`final`，是编译期常量，`val`是运行时常量，编译器在编译期无法确定它的值，本质是个变量，仍然可以通过反射修改值
* `typealias`：类型别名，例：`typealias OnClick = (View)->Unit`