![](https://gitee.com/hysbtr/pic/raw/master/http_cache.png)

## 强制缓存
* 需要服务端参与判断是否继续使用缓存，当客户端第一次请求数据时，服务端返回了缓存的过期时间(`Expires`或`Cache-Control`)，下次请求时，没有过期就可以继续使用缓存，否则则不适用，无需再向服务端询问。
* `Expires`：`Expires`的值为服务端返回的到期时间，即下一次请求时，请求时间小于服务端返回的到期时间，直接使用缓存数据。到期时间是服务端生成的，客户端和服务端的时间可能有误差。
* `Cache-Control`：`Expires`有个时间校验的问题，所有`HTTP/1.1`采用`Cache-Control`替代`Expires`
* 强制缓存优先于对比缓存

### Cache-Control
字段 | 说明
:---: | :---:
no-cache | 需要使用对比缓存来验证缓存数据
no-store | 所有内容都不会缓存，强制缓存，对比缓存都不会触发 
only-if-cached | 不进行网络请求，只使用缓存
max-age | 缓存的内容将在 xxx 秒后失效
private | 客户端可以缓存
public | 客户端和代理服务器都可缓存

### 对比缓存

* 需要服务端参与判断是否继续使用缓存，当客户端第一次请求数据时，服务端会将缓存标识（`Last-Modified`或`ETag`）与数据一起返回给客户端，客户端将两者都备份到缓存中 ，再次请求数据时，客户端将上次备份的缓存标识(`If-Modified-Since`或`If-None-Match`)发送给服务端，服务端根据缓存标识进行判断，如果返回304，则表示通知客户端可以继续使用缓存。

* `ETag`/`If-None-Match`：
	* 客户端发送第一次请求，服务端会返回：`ETag: "5694c7ef-24dc"`
	* 客户端再次发送请求，请求头中携带：`If-None-Match: "5694c7ef-24dc"`
	* 服务端接收到客户端发来的资源标识码，则会与自己当前的资源吗进行比较：
		* 不同，则说明资源已经被修改，则返回200
		* 相同，则说明资源没有被修改，返回 304，客户端可以继续使用缓存
	* `ETag`优先级高于`Last-Modified`

* `Last-Modified`/`If-Modified-Since`：
	* 客户端发送第一次请求，服务端返回资源上次修改的时间：`Last-Modified:  Tue, 12 Jan 2016 09:31:27 GMT`
	* 客户端再次发送请求，请求头中携带：`If-Modified-Since: Tue, 12 Jan 2016 09:31:27 GMT`，将上次服务端返回的资源时间上传给服务端
	* 服务端接收到客户端发来的资源修改时间，与自己当前的资源修改时间进行对比：
		* 自己的资源修改时间大于客户端发来的资源修改时间，则说明资源做过修改， 则返回200表示需要重新请求资源
		* 自己的资源修改时间小于客户端发来的资源修改时间，返回304表示资源没有被修改，可以继续使用缓存

