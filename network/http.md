[TOC]

## Http
* Hyper Text Transfer Protocol(超文本传输协议)
* 基于`TCP/IP`，默认端口号`80`
* `请求、相应模型`：一次请求对应一次响应
* `无状态`：每次请求之间相互独立，不能交互数据

### Http通信过程
![](https://gitee.com/hysbtr/pic/raw/master/http.png)

## 请求报文
![](https://gitee.com/hysbtr/pic/raw/master/request_message.png)

### 请求行
#### 请求方式
请求方式 | 介绍
:--: | ---
GET | 请求参数在请求行中，请求url长度有限制，不安全
POST | 请求参数在请求体中，可用来下载文件，url中没有请求参数
PUT | 向指定资源位置上传其最新内容
DELETE | 请求服务器删除 Request-URI 所标识的资源

#### 路径
* /v1/core/time

#### 请求协议/版本
* `1.0`：每次请求前都要建立连接，响应后都要断开连接
*  `1.1`：每次请求前复用之前的连接(如果有)、响应后过一会再断开连接
* 建立连接耗时耗资源

### 请求头
名称 | 作用
:---: | ---
User-Agent | 浏览器版本信息
Content-Type | 请求体类型
Accept | 浏览器支持解析的文件格式
Accept-Encoding | 浏览器支持的压缩格式
Connection | keep-alive，请求完成后仍保留一段时间的连接 
Transfer-Encoding | chunked(分块传输)，传输编码格式，配合Content-Encoding使用 
Content-Encoding | gzip，内容编码格式，适合压缩文本 
Content-Length | 内容长度，一般不与Transfer-Encoding同时使用，因为长度不确定 
Referer | 告诉服务器，我从哪里来(1.防盗链，2.统计)

#### Content-Type
Content-Type | 解释
:---: | :--:
text/html | html格式
text/plain | 纯文本格式
text/css | CSS格式
text/javascript | js格式
image/gif | gif图片格式
image/jpeg | jpg图片格式
image/png | png图片格式
application/x-www-form-urlencoded | POST专用：普通的表单提交默认是通过这种方式。form表单数据被编码为key/value格式发送到服务器。
application/json | POST专用：用来告诉服务端消息主体是序列化后的 JSON 字符串
text/xml | POST专用：发送xml数据
multipart/form-data | POST专用：用以支持向服务器发送二进制数据，以便可以在 POST 请求中实现文件上传等功能 

#### Transfer-Encoding
* 报文中的实体改为用一系列分块来传输
* 每个分块包含十六进制的长度值和数据
* 长度值独占一行，长度不包括它结尾的`\r\n`
* 最后一个分块长度值必须为 0，对应的分块数据没有内容，表示实体结束

### 请求体
* `POST`请求才有貌似

## 响应报文
![](https://gitee.com/hysbtr/pic/raw/master/response_message.png)

### 响应行
#### 状态码
状态码 | 含义
:---: | ---
1XX | 提示信息，表示已接收请求，正在处理
2XX | 请求正常处理完成
3XX | 重定向
4XX | 客户端错误
5XX | 服务端错误

### 响应头
* 同请求头

### 响应体
* 返回数据

## 缓存
![](https://gitee.com/hysbtr/pic/raw/master/http_cache.png)

### 强制缓存
* 需要服务端参与判断是否继续使用缓存，当客户端第一次请求数据时，服务端返回了缓存的过期时间(Expires与Cache-Control)，下次请求时，没有过期就可以继续使用缓存，否则则不适用，无需再向服务端询问。
* Expires：Expires的值为服务端返回的到期时间，即下一次请求时，请求时间小于服务端返回的到期时间，直接使用缓存数据。到期时间是服务端生成的，客户端和服务端的时间可能有误差。
* Cache-Control：Expires有个时间校验的问题，所有HTTP1.1采用Cache-Control替代Expires
* Cache-Control的取值有以下几种：
	* private：客户端可以缓存
	* public：客户端和代理服务器都可缓存
	* max-age=xxx：缓存的内容将在 xxx 秒后失效
	* no-cache：需要使用对比缓存来验证缓存数据
	* no-store：所有内容都不会缓存，强制缓存，对比缓存都不会触发
* 强制缓存优先于对比缓存

### 对比缓存

* 需要服务端参与判断是否继续使用缓存，当客户端第一次请求数据时，服务端会将缓存标识（Last-Modified/If-Modified-Since与Etag/If-None-Match）与数据一起返回给客户端，客户端将两者都备份到缓存中 ，再次请求数据时，客户端将上次备份的缓存 标识发送给服务端，服务端根据缓存标识进行判断，如果返回304，则表示通知客户端可以继续使用缓存。
* Last-Modified/If-Modified-Since：
	* 当客户端发送第一次请求时，服务端返回资源上次修改的时间，Last-Modified: Tue, 12 Jan 2016 09:31:27 GMT
	* 客户端再次发送，会在header里携带If-Modified-Since。将上次服务端返回的资源时间上传给服务端，If-Modified-Since: Tue, 12 Jan 2016 09:31:27 GMT
	* 服务端接收到客户端发来的资源修改时间，与自己当前的资源修改时间进行对比，如果自己的资源修改时间大于客户端发来的资源修改时间，则说明资源做过修改， 则返回200表示需要重新请求资源，否则返回304表示资源没有被修改，可以继续使用缓存
* Etag/If-None-Match：
	* ETag是资源文件的一种标识码，当客户端发送第一次请求时，服务端会返回当前资源的标识码，ETag: "5694c7ef-24dc"
	* 客户端再次发送，会在header里携带上次服务端返回的资源标识码，If-None-Match:"5694c7ef-24dc"
	* 服务端接收到客户端发来的资源标识码，则会与自己当前的资源吗进行比较，如果不同，则说明资源已经被修改，则返回200，如果相同则说明资源没有被修改，返回 304，客户端可以继续使用缓存
	* ETag优先级高于Last-Modified

## Https
![](https://gitee.com/hysbtr/pic/raw/master/https_chart.png)

1. 客户端发起HTTPS请求，请求信息包含客户端支持的加密算法
2. 服务端的配置
服务端确认支持此加密算法。采用HTTPS协议的服务器必须要有一套数字证书，可以是自己制作或者CA证书。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用CA证书则不会弹出提示页面。这套证书其实就是一对公钥和私钥。公钥给别人加密使用，私钥给自己解密使用。
3. 传送证书
这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等。
4. 客户端解析证书
这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随即值，然后用证书对该随机值进行加密。
5. 传送加密信息
这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。
6. 服务段解密信息
服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密。所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。
7. 传输加密后的信息
这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。
8. 客户端解密信息
客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容。
PS: 整个握手过程第三方即使监听到了数据，也束手无策。

## Http版本
#### http2
* 多路复用：就是针对同个域名的请求，都可以在同一条连接中并行进行，而且头部和数据都进行了二进制封装。
* 二进制分帧：传输都是基于字节流进行的，而不是文本，二进制分帧层处于应用层和传输层之间。
* 头部压缩：HTTP1.x每次请求都会携带完整的头部字段，所以可能会出现重复传输，因此HTTP2采用HPACK对其进行压缩优化，可以节省不少的传输流量。
* 服务端推送：服务端可以主动推送数据给客户端。