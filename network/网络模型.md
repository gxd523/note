[TOC]

## 网络模型
![](https://gitee.com/hysbtr/pic/raw/master/network_1.png)
![](https://gitee.com/hysbtr/pic/raw/master/network_2.png)
![](https://gitee.com/hysbtr/pic/raw/master/network_3.png)

## TCP三次握手
![](https://gitee.com/hysbtr/pic/raw/master/three_times_handshake.png)

* 第一次：客户端向服务端发送请求。SYN=1,seq=x
* 第二次：服务端接收到请求，确定和客户端连接成功，但客户端并不知道服务端是否接收到请求，所以需要第二次握手，服务端向客户端发送确认连接。ACK=1,ack=x+1,SYN=1,seq=y
* 第三次：假如服务端收到一个已经失效的客户端连接请求，服务端无法判断失效，还会继续向客户端发送确认连接，并为客户端保留端口资源，浪费了服务端资源。所以需要第三次握手，客户端再次确认连接是否失效。ACK=1,ack=y+1,seq=x+1

关键字 | 大小 | 含义
--- | ---
序列号seq | 4字节 | 用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号
序列号ack | 4字节 | 
确认标志位ACK | 1位 | 1表示有效，0表示无效
同步标志位SYN | 1位 | 1表示同步连接，0表示已完成
终止标志位FIN | 1位 | 1表示数据发送完毕，0表示

## 四次挥手
![](https://gitee.com/hysbtr/pic/raw/master/four_times_wave.png)

* 第一次：客户端向服务端发送请求，向主动关闭连接
* 第二次：服务端收到请求，像客户端发送请求确认收到，但没有关闭SOCKET
* 第三次：服务端确认没有数据要发送了，才真正关闭SOCKET，并向客户端发送请求
* 第四次：客户端向服务端发送请求，并在2MSL后关闭，服务端收到请求后关闭连接。

#### 为什么关闭是4次挥手
因为服务端收到客户端发来的请求后，立即向客户端发送请求表示已收到消息，但是还不能立即关闭连接，要等服务端将可能还未发送给客户端的数据发送完后才能再次向客户端发送请求，表示服务端真的关了连接。

#### 为什么客户端最后要等2MSL(2个报文最大生命周期)才能CLOSE
怕服务端没收到最后客户端发送的消息，服务端没有收到ACK，会一直发送发送消息确认

## 长连接
* 长连接是指传输层TCP保持长连接，而不是应用层的Http
* 需要客户端、服务端都设置`Connection:keep-alive`才行
* 大部分连接都是长连接
* 长连接好处：例如访问一个网站，里面包含的CSS、JS、图片等一系列请求，都可以复用这个TCP连接，不必每个请求都建立连接三次握手
* `Keep-Alive: timeout=20`：长连接的超时时间以客户端、服务端中最短的为准