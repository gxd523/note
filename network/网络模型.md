### 网络模型
![](https://github.com/gxd523/note/raw/master/pic/network_1.png)
![](https://github.com/gxd523/note/raw/master/pic/network_2.png)
![](https://github.com/gxd523/note/raw/master/pic/network_3.png)

### TCP三次握手
![](https://github.com/gxd523/note/raw/master/pic/three_times_handshake.png)

* 第一次：客户端向服务端发送请求。SYN=1,seq=x
* 第二次：服务端接收到请求，确定和客户端连接成功，但客户端并不知道服务端是否接收到请求，所以需要第二次握手，服务端向客户端发送确认连接。ACK=1,ack=x+1,SYN=1,seq=y
* 第三次：假如服务端收到一个已经失效的客户端连接请求，服务端无法判断失效，还会继续向客户端发送确认连接，并为客户端保留端口资源，浪费了服务端资源。所以需要第三次握手，客户端再次确认连接是否失效。ACK=1,ack=y+1,seq=x+1

关键字 | 大小 | 含义
--- | ---
序列号seq | 4字节 | 用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号
序列号ack | 4字节 | 
确认标志位ACK | 1位 | 1表示有效，0表示无效
同步标志位SYN | 1位 | 1表示同步连接，0表示已完成
终止标志位FIN | 1位 | 1表示数据发送完毕，0表示

### 四次挥手
![](https://github.com/gxd523/note/raw/master/pic/four_times_wave.png)

* 第一次：客户端向服务端发送请求，准备关闭向服务端的数据连接。
* 第二次：服务端收到请求，关闭等待，服务端向客户端发送请求确认可以关闭。
* 第三次：服务端向客户端发送请求，准备关闭向客户端的数据发送。
* 第四次：客户端向服务端发送请求确认可以关闭，服务端关闭连接。
