[TOC]

## 网络模型
![](https://raw.githubusercontent.com/gxd523/PictureBed/master/network_1.png)
![](https://raw.githubusercontent.com/gxd523/PictureBed/master/network_2.png)
![](https://raw.githubusercontent.com/gxd523/PictureBed/master/network_3.png)

## TCP三次握手
![](https://raw.githubusercontent.com/gxd523/PictureBed/master/three_times_handshake.png)

* 第一次：客户端向服务端发送请求。SYN=1,seq=x
* 第二次：服务端接收到请求，确定和客户端连接成功，但客户端并不知道服务端是否接收到请求，所以需要第二次握手，服务端向客户端发送确认连接。ACK=1,ack=x+1,SYN=1,seq=y
* 第三次：假如服务端收到一个已经失效的客户端连接请求，服务端无法判断失效，还会继续向客户端发送确认连接，并为客户端保留端口资源，浪费了服务端资源。所以需要第三次握手，客户端再次确认连接是否失效。ACK=1,ack=y+1,seq=x+1

关键字 | 大小 | 含义
--- | ---
序列号seq | 4字节 | 用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号
序列号ack | 4字节 | 
确认标志位ACK | 1位 | 1表示有效，0表示无效
同步标志位SYN | 1位 | 1表示同步连接，0表示已完成
终止标志位FIN | 1位 | 1表示数据发送完毕，0表示

## 四次挥手
![](https://raw.githubusercontent.com/gxd523/PictureBed/master/four_times_wave.png)

* 客户端向服务端发送请求：表示后续不会再向服务端发送数据了，并准备关闭发送通道
* 服务端收到请求，关闭接收通道，向客户端发送请求，并检查有没有数据要发送给客户端，客户端收到请求关闭发送通道
* 服务端确认没有数据要发送了，准备关闭发送通道，并向客户端发送请求
* 客户端收到请求，向服务端发送请求，然后2MSL后关闭，服务端收到请求后关闭发送通道

#### 为什么关闭是4次挥手
* TCP连接是全双工通信，有两条链路，双方都能同时发送、接收信息
* 所以双方要关闭自己的发送通道，都要各自发送一次请求
* 收到请求后，关闭自己的接收通道，然后再发送一次确认请求，发送通道才能关闭
* 否则，假如对方没有接到关闭发送通道的消息，仍会开着接收通道

#### 为什么客户端最后要等2MSL(2个报文最大生命周期)才能CLOSE
怕服务端没收到最后客户端发送的消息，服务端没有收到ACK，会一直发送发送消息确认

## 长连接
* 长连接是指传输层TCP保持长连接，而不是应用层的Http
* 需要客户端、服务端都设置`Connection:keep-alive`才行
* 大部分连接都是长连接
* 长连接好处：例如访问一个网站，里面包含的CSS、JS、图片等一系列请求，都可以复用这个TCP连接，不必每个请求都建立连接三次握手
* `Keep-Alive: timeout=20`：长连接的超时时间以客户端、服务端中最短的为准