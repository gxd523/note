[TOC]

## 1、Glide配置
* 自定义添加注解`@GlideModule`，并继承`AppGlideModule`的配置类
* 实现方法的参数中拿到`GlideBuilder`、`Registry`，进行配置
* Glide通过`注解处理器`拿到自定义配置类，通过`javapoeat`生成`GeneratedAppGlideModuleImpl`
* 将自定义配置类作为`GeneratedAppGlideModuleImpl`的代理属性，实现具体的配置方法
* `Glide`初始化时，反射创建出`GeneratedAppGlideModuleImpl`实例，调用方法，传入`GlideBuilder`、`Registry`，完成配置

##  2、Glide生命周期管理
* `Glide`通过`GlideBuilder`构建出实例，获取`RequestManagerRetriever`
* 通过`RequestManagerRetriever.fragmentGet()`构建`RequestManagerFragment`
* `RequestManagerFragment`内实例化`Lifecycle`，及通过`RequestManagerFactory`创建的`RequestManager`
* `RequestManager`实现`LifecycleListener`，并添加到`Lifecycle`的`Observer`集合中
* 在`RequestManagerFragment`的`onStart)()`、`onStop()`、`onDestroy`中通过`Lifecycle`回调`LifecycleListener`的声明周期方法
* 在`RequestManager.track()`中，`TargetTracker`、`RequestTracker`分别设置`Target`，及`Request`
* `TargetTracker`、`RequestTracker`分别用来管理用`Target`集合、`Request`集合的生命周期
* 在`RequestManager`实现的`LifecycleListener`的声明周期方法被回调时，分别调用`TargetTracker`、`RequestTracker`的相应方法传递声明周期
* `RequestManager.track()`在`RequestBuilder.into()`中被调用
* `Target`在生命周期回调中主要处理`Animatable`

## 3、内存获取Resource
* 通过`GlideContext`的`TargetFactory`创建`Target`实例
* 调用`RequestBuilder.into()`，并传入`Target`等参数
* 通过`buildRequest()`获取`Request`，默认是`SingleRequest`，设置了`thumbnail`则是`ThumbnailRequest`，内部包含2个`Request`
* 调用`RequestManager.track()`，接着`RequestTracker.runRequest()`
* 如果当前是`onStop()`生命周期、`onTrimMemory()`，`isPaused`，`request.clear()`
* 否则，`Request.begin()`，开始`Request`为`WAITING_FOR_SIZE`状态，如果`overrideSize`未设置，则通过`Target.getSize()`获取控件尺寸
* 优先使用`paramSize`，其次使用`view.getWidth()`，最后使用`ViewTreeObserver.addOnPreDrawListener()`
* 获取到`viewSize`之后，调用`Engine.load()`
* 通过`KeyFactory`拿到key，如果`skipMemory`不为true，就先从内存中取`Resource`
* 先从`ActivityResources`拿，拿到了`Resource`引用数`acquire`+1
* 再从`MemoryCache.remove(key)`的返回值拿，拿到后加进`ActivityResource`，同样`acquire`+1

## 4、磁盘缓存&网络获取Data
* 构建`EngineJob`，它持有`DiskCache`、`Source`等`Executor`
* `DecodeJob`，是一个`Runnable`，执行`EngineJob.start(decodeJob)`
* 通过`DecodeJob.getNextStage()`，里面判断`DiskCacheStrategy`，来确定下一阶段，该从`RESOURCE`、`DATA`还是`SOURCE`的`Generator`中取`Resouce`
* 调用`Generator.startNext()`，通过返回boolean判断
* 先从`DiskCache`中拿到图片`File`
* 在`ModelLoaderRegistry`中通过`Model`(File)拿到匹配的`ModelLoader`
* 调用`ModelLoader.buildLoadData()`，拿到`LoadData`
* 调用`LoadData.Fetcher.loadData()`，将`Model`转成`Data`类型
* `SourceGenerator`会在`onDataReady()`回调中，判断判断缓存策略，存储`DATA`缓存，执行`reschedule()`，重新走一遍`DecodeJob`

## 5、Data解码成Resource\<Drawable>
* 从`onDataReady()`开始，进入解码阶段
* 经过一系列方法，带着控件`宽高`，到达`DecodePath.decode()`
* 最终调用`BitmapFactory.decode()`返回`Resource<Drawable>`
* 在回调方法`onResourceDecoded()`中执行`transform()`转换
* 并判断是否设置`RESOURCE`缓存，并存储`RESOURCE`缓存
* 一路向外传递`target.onResourceReady()`
* 最终调用`ImageView.setImageDrawable()`

