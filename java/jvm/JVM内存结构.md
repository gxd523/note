[TOC]

## JVM内存结构
> 与Java虚拟机的运行时区域有关(3室2厅)

![](https://raw.githubusercontent.com/gxd523/PictureBed/master/JMS.png)

区域 | 存储内容 | 特点
:---: | :---: | :---:
堆 | 对象、数组等new出来的东西 | 运行时动态分配
方法区 | 类信息、静态变量&静态引用、常量 | 
Java栈 |  基本数据类型、对象的引用 | 编译时确定大小，运行时不会改变
native方法栈 | native方法| 
程序计数器 | 当前线程执行字节码的行号(上下文切换保存现场)| 

* 程序计数器、Java栈、native方法栈都是随线程生命周期，因为是线程私有区域
* 静态变量存储在`方法区`，引用类型为地址，基础类型为值


### 堆
* 引用类型所指向的对象都存储在`堆`中，包括`方法区`中的静态变量、`栈`中的局部变量，但指向常量池的除外
* `JDK1.7`开始，`字符串池`从`方法区`的`运行时常量池`移到了`堆`中，堆中的字符串常量池里放的是字符串的引用，而不是字符串本身

### 方法区

* 静态常量池：存储在字节码文件中，一个类的名字、属性的名字及类型、方法的名字及类型及返回值的类型等符号引用，还有程序中出现的字面量
* 运行时常量池：在方法区中，当类加载到内存后，JVM就会将字节码文件中的常量部分放入运行时常量池中；字节码中的符号引用会被替换为直接引用

#### 字面量
* 基础类型值

#### 符号引用
* 在字节码中用来表示引用类型的值，因为此时还未运行，没法指向内存地址
* 运行时会替换为直接引用

### Java虚拟机栈
* 每执行一个方法都会在`Java栈`中创建一个栈帧
* `Java栈`会抛出OutOfMemoryError、StackOverflowError
* 执行的方法中的变量也存储在`Java栈`，基础类型为值，引用类型为地址