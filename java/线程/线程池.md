[TOC]

## 线程池
### newFixedThreadPool
> 创建一个固定数量的线程池

* 每提交一个任务就创建一个线程
* 如果线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中
* 线程池中没有可运行任务时，它不会释放线程，还会占用一定的系统资源

### newCachedThreadPool
> 创建一个可缓存的线程池

* 线程的创建数量几乎没有限制(<Interger. MAX_VALUE)
* 终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程
* 线程池中没有可运行任务时，即线程空闲了1分钟(默认)，它会释放线程，从而释放工作线程所占用的资源

### newSingleThreadExecutor
> 只创建一个线程来执行任务，如果这个线程异常结束，会有另一个取代它，保证顺序执行

### newScheduleThreadPool
```java
ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(2);
final ScheduledFuture<?> schedule = scheduledExecutorService.scheduleWithFixedDelay(new Runnable() {
    @Override
    public void run() {
        Log.d("gxd", "ScheduledExecutorService.run-->" + Thread.currentThread().getName());
    }
}, 0, 5, TimeUnit.SECONDS);

scheduledExecutorService.schedule(new Runnable() {
    @Override
    public void run() {
        schedule.cancel(true);
    }
}, 30, TimeUnit.SECONDS);
```

### 关闭线程池
* 查看相关信息：
```java
// PID
String name = ManagementFactory.getRuntimeMXBean().getName();
System.out.println(name);
// 打印线程
ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();
for (ThreadInfo threadInfo : threadMXBean.getThreadInfo(threadMXBean.getAllThreadIds())) {
    System.out.println(threadInfo.getThreadName() + "..." + threadInfo.getThreadState());
}
// 线程总数
System.out.println(threadMXBean.getThreadCount() + "..." + threadMXBean.getDaemonThreadCount());
```
* 关闭：
```java
threadPool.shutdown();
while (!threadPool.isTerminated()) {
    // ignore
}
```

### Runnable&Callable区别
* `Runnable`只能内部处理异常，`Callable`可以抛出异常
* `Runnable`没有返回值，`Callable`有
* 使用`Callable`后，要调用`ExecutorService.shutdown()`，`Runnable`不用

### submit()&execute()区别
* execute()没有返回值
* submit()返回一个future来判断任务是否成功
* `submit()`返回