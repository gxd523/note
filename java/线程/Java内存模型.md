[TOC]

### JVM内存结构
> 与Java虚拟机的运行时区域有关(3室2厅)

![](https://gitee.com/hysbtr/pic/raw/master/JMS.png)

区域 | 存储内容 | 特点
:---: | :---: | :---:
堆 | 对象、数组等new出来的东西 | 运行时动态分配
方法区 | 类信息、静态变量&静态引用、常量 | 
Java栈 |  基本数据类型、对象的引用 | 编译时确定大小，运行时不会改变
native方法栈 | native方法| 
程序计数器 | 当前线程执行字节码的行号(上下文切换保存现场)| 

* 程序计数器、Java栈、native方法栈都是随线程生命周期，因为是线程私有区域


### Java内存模型(JMM)
> 对不同内存硬件的抽象，为了多线程安全，是一种规范

#### 重排序

##### 重排的3种情况
* 编译器优化：包括JVM、JIT编译器等
* CPU指令重排：例如a=1;b=1;a=a+3;，会先加载a，把a设置为1，再把a设置为4，在存储a，在弄b
* 内存的“重排序”：线程A的修改，线程B却看不到，主存与本地内存不一致导致，可见性问题
* 注意：数据存在依赖关系时不允许重排序
* final可以禁止重排序

#### 可见性
* 线程间通过主存进行通信，有一定的延迟，不能同步更新
* 线程间对于共享变量的可见性问题不是由多核引起的，而是由多级缓存引起的，多级缓存导致对变量的修改需要一级级缓存进行同步，而同步不是实时的，就导致了可见性问题

![](https://gitee.com/hysbtr/pic/raw/master/visibility.png)

##### 本地缓存(local cache)
> 每个线程自己的缓存，也可叫本地内存或工作内存，是一个抽象概念，可以对应于上图的寄存器到2级缓存，但不同处理器有所不同

##### 共享缓存(shared cache)
> 线程间共享的缓存，也可叫主内存，是一个抽象概念，可以对应于上图的3级缓存到RAM，但不同处理器有所不同

##### 主内存、工作内存关系
* 所有变量都存在主内存中，同时每个线程也有自己的工作内存，工作内存的变量是主内存的拷贝
* 线程不能直接修改主内存的变量，需要先先拷贝到自己的工作内存中做修改，再同步到主内存中
* 主内存是多个线程共享的，工作内存是各个线程私有的，线程间通信必须通过主内存来完成
* 操作系统会尽可能抓住机会同步主内存与工作内存，而不是等到要用的时候才同步

##### Happens-Before原则(解决可见性问题)
> 动作A发生在动作B之前，B保证能看见A

* 单线程规则
* 锁操作(synchronize&Lock)
* volatile
* 线程start()，子线程对主线程启动子线程之前的操作可见
* 线程join()
* 传递性
* 中断
* 构造方法
* ConcurrentHashMap
* CountDownLatch
* CyclicBarrier
* 信号量(Semaphore)
* Future

#### 原子性
* 一系列操作要么全部成功，要么不执行，不会出现执行一半的情况
* a++分为3个原子操作，取值(从地址中取值)、计算(计算a+1)、赋值(将计算结果存回地址)
##### 原子操作有哪些
* 除了long和double之外的基本类型(这两个在32位设备上是分2次32位读写，可用volatile解决)
* 所有引用的赋值操作
* java.util.concurrent.atomic包下的类

#### volatile
> volatile是一种同步机制，比synchronize或Lock更轻量，因为使用volatile并不会发生上下文切换等内存开销大的行为。

* 修改volatile变量，会先在工作线程修改，然后同步到主内存，最后标记其他工作内存的该变量过期，在其他线程读取变量时强制刷新共享缓存的变量值
* volatile能做到保证可见性、禁止重排序，但不能保证原子性
* volatile之所以能实现轻量级的同步是因为它遵循happens-before原则，volatile变量之前的操作会具有可见性，volatile修饰的变量之前的操作会刷新
* volatile开销远远小于synchronize
* volatile不适用于多个线程a++的场景，因为没有原子操作的能力
* volatile适用于单一原子操作，例如直接赋值，而不是a++这种先取值、再计算、再赋值
* volatile适用于触发器，根据happens-before原则，刷新volatile修饰变量之前的操作

##### volatile&synchronize区别
* volatile不会切换上下文，只是刷新volatile变量在主内存的值

### Java对象模型
> Java对象在Java虚拟机的表现形式

![](https://gitee.com/hysbtr/pic/raw/master/JOM.png)

* 字节码文件是跨平台的，每个平台的JVM会将字节码文件“翻译”成对应平台的机器指令
* 

 

