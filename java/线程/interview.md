#### 既然Thread.start()只能调用1次。那么线程池是如何实现线程复用的呢?
> 假如线程池重复使用1个线程，在这个线程的run()里循环获取存入BlockingQueue的Runnable，集合为空时阻塞循环。

#### 线程为什么不能suspend()、stop()
> 线程来不及收拾残局。停止线程相当于开门，你可以敲门(thread.interrupt())，对方可以不开(无视thread.isInterrupted())，如果对方睡着了(Waiting)，你可以打电话让对方开门(响应中断异常)，但你不能破门而入(thread.stop())

#### 什么是线程安全
> 线程间`共享`的`可变`资源，运行结果不正确。

#### 为什么wait必须在同步代码块中使用?
> 我们一般会在一个线程调用wait()，在另一个线程调用notify()，假如这两个方法不受同一把锁的同步代码块保护，那极有可能发生后调用的notify()先执行了，造成永久等待。

#### 为什么线程通信的方法wait()、notify()被定义在Object类里?而sleep()定义在Thread类里?
> wait()、notify()都要指定等待/唤醒的目标，这个目标设定为锁更合适，因为持有锁的线程可能会更换，这样wait()、notify()等待/唤醒的线程也相应更换，所以更加灵活。
>
> 线程在run()结束后会自动调用notify()。
> 锁对象.wait()是让当前锁所在的线程进入等待状态，也就是说在不同线程调用可使多个线程进入等待状态，锁对象.notifyAll()是唤醒之前调用这个锁对象.wait()进入等待状态的线程。
> 如果wait()/notify()只在Thread类里的话

#### suspend()&resume()来阻塞线程可以吗?
> 这两个类似于wait()、notify()，但不释放锁，所以容易引起死锁。

#### sleep()&wait()异同
* 都可以阻塞线程
* 都可以相应中断异常
* wait()需要在通读代码块中执行
* wait()释放锁，sleep()不释放

#### jion期间，线程处于什么状态
> Waiting状态

#### 守护线程&普通线程区别
> 守护线程用来守护普通线程，因而当守护线程所守护的普通线程执行完毕后，守护线程也会终止。

#### 为什么程序设计不应依赖线程优先级
> 线程优先级最终是由线程调度器来决定的，所以设置优先级高低并不一定能保证最终运行的优先级。其次Java的10个优先级映射到不同的操作系统情况不同，所以不靠谱。

#### 异常体系
> Throwable分别有Error、Exception两个子类，Error代表无法挽回的错误，Exception又分为RuntimeException和编译时异常，RuntimeException编译器无法检查。

#### 哪些情况需要注意线程安全问题
> 多线程并发访问共享变量或资源

#### 为什么多线程会影响性能
> 多线程需要上下文切换，同步内存

#### volatile适用哪些场合，不适用哪些场合
> 一个线程修改变量，多个线程读取变量，作为触发器刷新之前的变量，不适用a++
> 或者多个线程多只对变量进行例如赋值这样的原子操作

#### volatile&synchronize区别
> volatile不能保证原子性，但不会导致上下文切换，更加轻量
