[TOC]
### CPU
> CPU的核心数代表硬件上存在着几个核心，这些核心是相对独立的CPU核心单元组。在没有超线程技术的时候，一个核心只能处理一个线程，而有了超线程技术后，一个核心可以处理两个线程。例如双核心四线程。就是有两个CPU核心而每个核心可以处理的线程数就是两个。

### 进程
> 进程即为程序运行的资源分配和调用的基本单位，而进程里面是存在多个线程。进程中的每个线程都会共享进程中的资源。例如启动我们的JAVA应用就是启动一个进程，每个请求我们都使用一个线程处理，而每个请求中使用到的全局变量这些就是共享的资源。

### 线程
> 线程是CPU执行的基本单位。线程可以把进程的资源分配和执行调度分开，各个线程既可以共享进程资源，又可以独立调度。而在同一时间片刻下CPU只能执行1个线程。多线程执行CPU通过分配给每个线程的执行时间段以达到多线程计算。这种切换会导致上下文切换。而频繁的上下文切换会影响性能。

### CPU时间片
> CPU时间片即CPU分配给每个线程的执行时间段，称作它的时间片。CPU时间片一般为几十毫秒(ms)。

### 线程调度
> 线程调度就是系统为线程分配执行时间的过程。

### 线程调度的方式
* **协同式线程调度**：线程之间的系统执行时间，由线程本身进行进行控制。这种线程调度方式就像接力赛，一个执行完毕后交由下一个接力。如当前线程执行完毕后，通知系统调度到其他线程执行。
	* 协同的好处：线程的切换是可预知的。线程之间不存在同步的问题。
	* 协同的坏处：协同调度的致命缺点是当某个线程执行有问题的时候，会导致整个运行阻塞和系统崩溃。
* **抢占式线程调度**：线程之间的系统执行时间，是由系统进行控制。而抢占式的线程调度对线程的不可预知，系统定期的中断当前正在执行的线程，将CPU执行权切换到下一个等待的线程。所以任何一个线程都不能独占CPU。正因为这种定期的线程切换导致线程之间存在不同的问题。当线程执行过程中，某个线程出现问题的时候，由线程对CPU不具有独占性。因此不会造成阻塞。

* Java线程调度就是抢占式调度。

### ThreadLocal
> 线程本地存储区（Thread Local Storage，简称为TLS）

* 线程本来是共享所在进程下的所有资源的，ThreadLocal则是每个线程私有的本地存储区域。
* 每个线程只能访问各自的线程本地存储区域，不能相互访问。
* ThreadLocal是一个线程对象的Map<ThreadLocal,T>成员变量。当线程结束后，线程的本地存储会被垃圾回收。
* 如果线程本地存储中的变量被其他引用到的情况下，是不会被回收。
* ThreadLocal实例最好全局静态final，不然一个线程有多个ThreadLocal实例

### Condition
> Condition是在java 1.5中才出现的，它用来替代传统的Object的wait()、notify()实现线程间的协作，相比使用Object的wait()、notify()，使用Condition的await()、signal()这种方式实现线程间协作更加安全和高效。因此通常来说比较推荐使用Condition。