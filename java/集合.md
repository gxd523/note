### Hash(散列)

- hashCode方法就是根据一定的规则将与对象相关的信息（比如对象的存储地址，对象的字段等）映射成一个数值，这个数值称作为**散列值**
- hashCode返回的不是对象的存储地址，而是哈希表中的位置
- 如果两个对象equals相等，那么这两个对象的HashCode一定也相同
- 如果两个对象的HashCode相同，不代表两个对象就相同，只能说明这两个对象在散列存储结构中，存放于同一个位置
- 哈希数据结构的集合查找、插入速度非常快，但遍历不方便
- 哈希表包含所有的哈希值
- 哈希表中同一个哈希值可能对应多个对象，一样可以减少比较次数(equals())

### List

* List中存储的数据是有顺序的，并且值允许重复
* `LinkedList`:基于链表实现，链表内存是散列的，增删快，查找慢
* `ArrayList`:基于数组实现，非线程安全，效率高，增删慢，查找快
* `Vector`:基于数组实现，线程安全，效率低，增删慢，查找慢

### Map

* Map中存储的数据是无序的，它的键是不允许重复的，但是值是允许重复的
* `HashMap`:基于 hash 表的 Map 接口实现，非线程安全，高效，支持 null 值和 null键
* `HashTable`:线程安全，低效，不支持 null 值和 null 键
* `LinkedHashMap`:HashMap 的一个子类，保存了记录的插入顺序
* `SortMap`:TreeMap，能够把它保存的记录根据键排序，默认是键值的升序排序

### Set

* Set中存储的数据是无顺序的，并且不允许重复，但元素在集合中的位置是由元素的hashcode决定，即位置是固定的（Set集合是根据hashcode来进行数据存储的，所以位置是固定的，但是这个位置不是用户可以控制的，所以对于用户来说set中的元素还是无序的）。
* `HashSet`:底层是由 Hash Map 实现，不允许集合中有重复的值，使用该方式时需要重写 equals()和 hash Code()方法
* `LinkedHashSet`:继承于 HashSet，同时又基于 LinkedHashMap 来进行实现，底层使用的是 LinkedHashMap，主要功能用于保证FIFO即有序的集合(先进先出)
* TreeSet的主要功能用于排序，可以指定自然顺序(Comparable)或比较器顺序(Comparator)
* `List`和`Set`是存储**单列数据的集合**，`Map`是存**储键值对这样的双列数据的集合**